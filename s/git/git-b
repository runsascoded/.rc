#!/usr/bin/python

from color import clen, color
from datetime import datetime
from dateutil.parser import parse
from util.regexs import refname_regex, captured_whitespace_regex
from util.reldate_util import shorten_reldate
import os
import re
import subprocess


def fixed(width, s):
    return (' ' * (width - clen(s))) + str(s)


# TODO:
#    * (no branch, rebasing master) da7a48d Comment on bottom bar in friend content.
#      bg                           dcaf33d [origin/ryan-buildgens] many base2 deps not needed bc of common.logging

class BranchInfo(object):
    hash_regex = "(?P<hash>[0-9a-f]+)"

    line_begin_regex = "(?P<line_begin>^(?:(?P<is_active>\*)| ) )"

    ahead_regex = "ahead (?P<ahead>[0-9]+)"
    behind_regex = "behind (?P<behind>[0-9]+)"
    ahead_behind_regex = ": (?:%s)?(?:, )?(?:%s)?" % (
        ahead_regex, behind_regex)
    tracking_info_regex = "(?:\s\[%s(?:%s)?\])?" % (
        refname_regex('tracking_name'), ahead_behind_regex)

    description_regex = "\s(?P<description>.*)"

    regex_pieces = [
        line_begin_regex,
        refname_regex('name'),
        captured_whitespace_regex('pre_hash'),
        hash_regex,
        tracking_info_regex,
        description_regex
    ]

    regex = ''.join(regex_pieces)

    def get(self, key, default=''):
        return self.dict[key] if key in self.dict and self.dict[key] != None else default

    def __init__(self, line):
        self.line = line

        match = re.match(self.regex, line)
        if (match):
            pass
        else:
            raise Exception("Invalid branch line:\n%s\nregex:\n%s" % (line, '\n'.join(self.regex_pieces)))

        self.dict = match.groupdict()

        self.colors = {
            'name': 'BGreen' if self.dict['is_active'] else 'BWhite',
            'hash': 'IRed',
            'remote': 'Yellow',
            'ahead_str': 'ICyan',
            'behind_str': 'IPurple',
            'date': 'IBlue',
            'reldate': 'IGreen',
            'description': 'White'
        }

        self.line_begin = self.get('line_begin')
        self.name = self.get('name')
        self.pre_hash = self.get('pre_hash')
        self.hash = self.get('hash')

        self.space = ' '

        self.remote = self.get('tracking_name')

        self.ahead = int(self.get('ahead', 0))
        self.ahead_str = "+%d" % self.ahead if self.ahead else ''

        self.behind = int(self.get('behind', 0))
        self.behind_str = "-%d" % self.behind if self.behind else ''

        self.pre_remote = ''  # '[' if self.remote else ' '
        self.post_remote = ''  # ']' if self.remote else ' '

        self.description = self.get('description')

    def colored_field(self, prop_name):
        my_val = getattr(self, prop_name)
        if prop_name in self.colors:
            return color(self.colors[prop_name], my_val)
        return my_val

    def field_string(self, prop_name, fixed_width_map):
        fixed_width = fixed_width_map[
            prop_name] if prop_name in fixed_width_map else 0
        return fixed(fixed_width, self.colored_field(prop_name))

    def to_string(self, fixed_width_map={}):

        fields = [
            'line_begin',
            'name',
            'pre_hash',
            'hash',
            'space',
            'pre_remote',
            'remote',
            'space',
            'ahead_str',
            'space',
            'behind_str',
            'post_remote',
            'space',
            'reldate',
            'space',
            'date',
            'space',
            'description'
        ]

        return ''.join(map(lambda field: self.field_string(field, fixed_width_map), fields))

    def __str__(self):
        return self.to_string()

    def set_dates(self, date, reldate):
        self.datetime = parse(date)

        self.date = datetime.strftime(self.datetime, '%Y-%m-%d %H:%M:%S')
        self.reldate = shorten_reldate(reldate)


class BranchInfos:

    def set_max(self, prop_name):
        self.maxs[prop_name] = max(
            map(lambda bi: clen(getattr(bi, prop_name) if hasattr(bi, prop_name) else ''), self.branches))

    def __init__(self):
        self.maxs = {}

        cmd = ["git", "branch", "-vv"]
        out, err = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()

        lines = out.splitlines()

        self.branches_by_name = {}
        self.branches_by_hash = {}

        for line in lines:
            info = BranchInfo(line)
            self.branches_by_name[info.name] = info
            if info.hash not in self.branches_by_hash:
                self.branches_by_hash[info.hash] = []
            self.branches_by_hash[info.hash].append(info)

        hashes = map(lambda bi: bi.hash, self.branches_by_name.values())
        cmd = ['git', 'show',
               # NOTE(ryan): seems to omit 'master' branch in Git 1.7.1; doesn't seem to be necessary in general.
               #'--quiet',
               '-s',
               '--format=%h\t%ci\t%cr'] + hashes
        out, err = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()

        lines = out.splitlines()
        for line in lines:
            if not line:
                continue
            cols = line.strip().split('\t')
            if len(cols) != 3:
                raise Exception(
                    'Expected 3 columns, found %d:\n%s\nfull output:\n%s' % (len(cols), cols, out))
            hsh, date, reldate = cols
            map(lambda bi: bi.set_dates(date, reldate),
                self.branches_by_hash[hsh])

        self.branches = sorted(
            self.branches_by_name.values(), key=lambda bi: bi.datetime, reverse=True)

        map(self.set_max, [
            'remote', 'ahead_str', 'behind_str', 'reldate', 'hash'])

        print ''
        for bi in self.branches:
            print bi.to_string(self.maxs)
        print ''


bis = BranchInfos()
