#!/usr/bin/python

import errno
import os
import re
import shutil
import subprocess
import sys
import tarfile
from tempfile import mkdtemp, NamedTemporaryFile
from util.remotes import get_remotes

remote=None

remote_names = []
if len(sys.argv) > 1:
  remote_names = [ sys.argv[1] ]
elif os.environ.get('MIRROR_REMOTES'):
  remote_names = os.environ.get('MIRROR_REMOTES').split(',')
else:
  raise Exception(
    'Pass remote name as an argument, or set MIRROR_REMOTES environment variable with a comma-separated list of eligible remotes'
  )

remotes = get_remotes()
found_remotes = [ remotes[remote] for remote in remote_names if remote in remotes ]
if len(found_remotes) > 1:
  raise Exception('Found multiple eligible remotes: %s' % ','.join(map(lambda remote: remote.group('name'), found_remotes)))
if not found_remotes:
  raise Exception('Found no eligible remotes: %s' % ','.join(remote_names))

remote = found_remotes[0]

# One weird trick: we can have all SSH commands in this run piggypack off of the same SSH connection
# by adding the following lines to ~/.ssh/config:
#
# Host *
#      ControlMaster auto
#      ControlPath ~/.ssh/master-%r@%h:%p
#
# This can save time and redundant connection overhead, which can be very useful on e.g. slow 
# connections.
#
# Credit to http://www.linuxjournal.com/content/speed-multiple-ssh-connections-same-server

ssh_channel = None
if not os.environ.get('SKIP_SSH_PIGGYBACKING'):
  ssh_channel = subprocess.Popen([ 'ssh', remote.group('host') ], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

print "Got remote %s at host %s. Pushing.." % (remote.group('name'), remote.group('host'))
subprocess.call([ 'git', 'push', remote.group('name') ])
print 'Pushed!'

try:
  tempdir = mkdtemp()

  unstaged_diff_file_basename = 'unstaged_diff_file'
  staged_diff_file_basename = 'staged_diff_file'

  unstaged_diff_file_path = os.path.join(tempdir, unstaged_diff_file_basename)
  staged_diff_file_path = os.path.join(tempdir, staged_diff_file_basename)

  tar_file_path = os.path.join(tempdir, 'diffs.tar.gz')

  with open(unstaged_diff_file_path, 'w') as unstaged_diff_file, \
          open(staged_diff_file_path, 'w') as staged_diff_file, \
          tarfile.open(tar_file_path, 'w:gz') as tar:

    subprocess.Popen(['git', 'diff'], stdout=unstaged_diff_file).wait()
    unstaged_diff_file.flush()

    subprocess.Popen(['git', 'diff', '--cached'], stdout=staged_diff_file).wait()
    staged_diff_file.flush()

    tar.add(staged_diff_file_path, arcname=staged_diff_file_basename)
    tar.add(unstaged_diff_file_path, arcname=unstaged_diff_file_basename)

  tar_basename = os.path.basename(tar_file_path)

  basenames_obj = { 
    'staged': staged_diff_file_basename, 
    'unstaged': unstaged_diff_file_basename, 
    'tar': tar_basename,
    'user': (remote.group('user') + '@') if remote.group('user') else '',
    'host': remote.group('host'),
    'path': remote.group('path'),
  }

  cmd = [ 
    'ssh', 
    remote.group('host'), 
    "; ".join(
      [ "cd %(path)s" % basenames_obj ] + 
      [ "ls %s 2> /dev/null" % filename for filename in [staged_diff_file_basename, unstaged_diff_file_basename, tar_basename]]
    )
  ]
  found_files = filter(lambda x: x, subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0].split('\n'))

  if found_files and len(found_files):
    inp = raw_input('Found existing files: %s. Overwrite? [Y/n]: ' % ','.join(found_files))
    if inp and inp.lower() != 'y':
      print 'Exiting'
      sys.exit(1)

  cmd = ['scp', tar.name, '%s:%s' % (remote.group('host'), remote.group('path'))]
  print "scp'ing tar file: %s" % ' '.join(cmd)
  subprocess.call(cmd)

  remote_cmd = ' && '.join([
    "cd %s" % remote.group("path"),
    "git reset --hard HEAD",
    "tar mxf %s" % tar_basename,
    "if [ -s %(staged)s ]; then echo 'applying staged diff'; git apply %(staged)s; git add .; git reset %(staged)s %(unstaged)s %(tar)s; fi" % basenames_obj,
    "if [ -s %(unstaged)s ]; then echo 'applying unstaged diff'; git apply %(unstaged)s; fi" % basenames_obj,
    "rm -rf $(git ls-files --other --exclude-standard)",
  ])

  print 'remote_cmd: %s' % remote_cmd

  subprocess.check_output([ 'ssh', remote.group('host'), remote_cmd ])

finally:

  if ssh_channel:
    ssh_channel.terminate()

  try:
    shutil.rmtree(tempdir)
  except OSError as exc:  
    if exc.errno != errno.ENOENT:  # ENOENT - no such file or directory
      raise  # re-raise exception    






